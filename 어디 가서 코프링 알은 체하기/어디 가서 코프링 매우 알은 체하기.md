# 어디 가서 코프링 매우 알은 체하기

**2021 9월 우아한 테크 세미나 - 박재성(Jason) 발표**

## 대상

- 코틀린을 웹 백엔드 언어로 도입했지만 코틀린답게 사용하고 있는지 의심스러운 분
- 코틀린의 매력을 느끼고 웹 백엔드 언어로 도입할 계획이지만 다른 사람들은 어떻게 개발하고 있는지 궁금한 분
- 지금은 무엇인지 모르겠으나 나중을 위해 미리 듣는 분

---

기존 백엔드 코틀린 사용기 (유튜브 업로드 되어 있음)

- 스프링캠프 2018 쿠팡 코틀린 적용기
- 카카오톡의 서버사이드 코틀린
- 페이코 매거진 서버 코틀린 적용기

---

## 코틀린이란?

- JVM, 안드로이드, 자바스크립트 및 네이티브를 대상으로 하는 정적 타입 지정 언어
- 젯브레인즈에서 개발한 오픈 소스 (아파치 라이선스 2.0)
- OO 스타일과 FP 스타일을 모두 사용할 수 있으며 두 요소를 혼합하여 사용할 수 있다.
- 간결하고 실용적이며 안전하고 기존 언어와의 상호 운용성을 중시한다. (+ 코루틴)
    - 코루틴: 강력한 코틀린의 라이브러리
- 코틀린 이라는 섬에서 유래 한 이름 - 러시아에서 군사적으로 중요한 위치

---

## 코틀린의 역사

- 2011년 7월 코틀린 프로젝트 공개
- 2012월 6월 안드로이드에서 사용 가능
- 2016년 2월 코틀린 1.0 출시
- 2016년 2월 스프링 이니셜라이저(스프링 부트) 지원
- 2017년 1월 스프링 프레임워크 공식 지원
- 2017년 5월 안드로이드 공식 지원
- 2018년 11월 그레이들 코틀린 DSL 1.0 출시
- 2019년 5월 안드로이드 코틀린 퍼스트
    - 공식 문서- 자바보다 코틀린 위주로 먼저 만들겠다는 의미
- 2019년 9월 스프링 레퍼런스 예제 코드 제공
- 2021년 5월 코틀린 1.5 출시

### 코틀린이 나오게 된 배경

- 자바의 업데이트 속도가 너무 느리다.
- 함수형 프로그래밍(람다 등..)을 하고싶다.
- 스칼라는 자바랑 같이 쓸 때 불편하다.
- 스칼라는 컴파일이 느리다.

---

## 얼마나 사용하고 있나요?

- 안드로이드 진영에서는 코틀린 퍼스트 선언 이후 굉장히 많이 사용중
- 지난 12개월 동안 480만 명 이상의 사용자가 사용
- 대다수의 코틀린 개발자는 안드로이드(63%) 및 서버 측 애플리케이션 개발(52%)에 사용한다.
- 대한민국에서 가장 인기가 많은 자바. 자연스럽게 코틀린에 대한 관심도 1위(10%)
    - 코틀린 언어의 발생지 러시아(8%)를 넘는 수치
    - 자바 역사의 뒤를 잇는 코틀린(?)
    

## 멀티 플랫폼 언어

**다양한 곳에서 언어를 사용할 수 있음**

- 안드로이드
- JVM
- 자바스크립트
- 네이티브

**컴파일**

Kotlin/JVM → .class

Kotlin/js → .js

---

## 아이템 1. 코틀린 표준 라이브러리를 익히고 사용하라

- 코틀린 1.3부터 모든 플랫폼에서 사용할 수 있는 kotlin.random.Random이 도입되었다.
    - Thread Safe 함
    - JDK 6, 7 에서는 ThreadLocalRandom 이 없지만 ThreadLocal 로 랩핑 한 Random Class 를 사용
- 더 이상 Random을 사용할지 ThreadLocalRandom을 사용할지 고민할 필요가 없다.
- 자바와 관련된 import문을 제거할 수 있다.
- 표준 라이브러리를 사용하면 그 코드를 작성한 전문가의 지식과 여러분보다 앞서 사용한 다른 프로그래머들의 경험을 활용할 수 있다.(*이펙티브 자바)
- 코틀린을 읽기 전용 컬렉션과 변경 가능한 컬렉션을 구별해 제공한다.
- 인터페이스를 만족하는 실제 컬렉션이 반환된다. 따라서 플랫폼별 컬렉션을 사용할 수 있다.

**자바와 관련 된 import 를 최대한 제거하면 자연스레 코틀린스러운 코틀린을 사용할 수 있다.**

## 코틀린 맛보기

```kotlin
class Person(val name: String, val age: Int = 1) {
	var nickname: String? = null
}
```

- **val:** 읽기 전용 프로퍼티
- **var:** 변경 가능한 프로퍼티
- **?:** 널이 될 수 있는 타입
- **= 1:** 기본 인자 제공

개발자가 의식적으로 노력하지 않아도 코드가 안전하게 작성된다.

ex: @NotNull, @Nullable, final ...

---

## 아이템 2. 자바로 역컴파일하는 습관을 들여라

- 코틀린 숙련도를 향상시키는 가장 좋은 방법 중 하나는 작성한 코드가 자바로 어떻게 표현되는지 확인하는 것이다.
- 역컴파일을 통해 예기치 않은 코드 생성을 방지할 수 있다.
- 기존 자바 라이브러리와 프레임워크를 사용하며 문제가 발생할 때 빠르게 확인할 수 있다.
- IntelliJ IDEA에서 Tools → Kotlin → Show Kotlin Bytecode → Decompile

## 코틀린 컴파일

Kotlin 기본 컴파일

*.kt, *.java → 코틀린 컴파일러 → *.class

Java → 점진적 Kotlin 도입

*.kt, *.java → 코틀린 컴파일러 → *.class, *.java → 애너테이션 프로세싱 → *.class

- 코틀린 컴파일러가 컴파일 한 이후 애너테이션 프로세싱이 일어남

---

## 아이템 3. 롬복 대신 데이터 클래스를 사용하라

- 데이터를 저장하거나 전달하는 것이 주 목적인 클래스를 만드는 경우가 많다. 이러한 클래스의 일부 표준 및 유틸리티 함수는 데이터에서 기게적으로 파생된다.
- 자바에서는 롬복의 @Data를 사용하여 보일러플레이트 코드를 생성한다.
- 애너테이션 프로세서는 코틀린 컴파일 이후에 동작하기 때문에 롬복에서 생성된 자바 코드는 코틀린 코드에서 접근할 수 없다.
    - 코틀린 컴파일 순서를 보면 코틀린 컴파일러가 컴파일 한 이후 롬복 애너테이션 프로세싱이 일어나기 때문
- 코틀린 코드보다 자바 코드를 먼저 컴파일하도록 빌드 순서를 조정하면 롬복 문제는 해결할 수 있다. 하지만 자바 코드에서 코틀린 코드를 호출할 수 없게 된다.
- 데이터 클래스를 사용하면 컴파일러가 equals(), hashCode(), toString(), copy() 등을 자동으로 생성해 준다.
    - 주 생성자를 기준으로 함
- 주 생성자에는 하나 이상의 매개변수가 있어야 하며 모든 매개변수는 val 또는 var 로 표시해야 한다.
- copy()를 적절히 사용하면 데이터 클래스를 불변으로 관리할 수 있다.
- 코드가 간단하기 때문에 한 코틀린 파일에 여러 관련 클래스를 담는 것도 좋은 방법이다.
- 코틀린 1.5부터 자바 16의 레코드 클래스도 지원한다.

```kotlin
val = javajigi = Person(name = "박재성", age = 49)
val jason = javajigi.copy(age = 30)

data class Person{}
```

- DTO, VO 에서 Data 클래스를 활용할 수 있다.

---

# Q&A

Q.코틀린을 학습하기 위해서 자바를 선행학습할 필요가 있을까요?

A.자바를 좀더 공부하시는걸 추천! 아직까지는 자바가..

Q.코틀린은 java8버전까지만 지원하나요?

A.자바 16이상도 지원 중..! 최신 버전 팔로우업 중!

Q. 코틀린과 자바를 같이 사용하면 하나의 언어만 사용했을때보다 컴파일시에 비용이 많이 드는걸까요?

A. 정확한 지적...! 많은 개발자들이 그래서 코틀린 넘어가는 것을 두려워하는 요인 중 하나! 성능은 차이없지만 로컬에서 빌드배포하는 시간이...좀 걸리는 경우 있어요

---

# 코프링

## final 클래스

- @SpringBootApplication은 @Configuration을 포함하고 스프링은 기본적으로 CGLIB을 사용하여 @Configuration 클래스에 대한 프록시를 생성한다.
- CGLIB는 대상 클래스를 상속하여 프록시를 만든다. final 클래스와 함수는 상속하거나 오버라이드 할 수 없으므로 프록시를 만들 수 없다.
- 상속을 허용하고 오

## All-open 컴파일러 플러그인

- 코틀린은 다양한 컴파일러 플러그인을 제공하며 all-open 컴파일러 플러그인은 지정한 애너테이션이 있는 클래스와 모든 멤버에 open 변경자를 추가한다.
- 스프링을 사용하는 경우 all-open 컴파일러 플러그인을 래핑한 kotlin-spring 컴파일러 플러그인을 사용할 수 있다.
- @Component, @Transaction, @Async 등이 기본적으로 지정된다.
- IntelliJ IDEA에서는 File > Project Structure > Project Settings > Modules > Kotlin > Compiler Plugins 에서 지정된 애너테이션을 확인할 수 있다.

---

## 아이템 4. 필드 주입이 필요하면 지연 초기화를 사용 하라

- 생성자를 통해 의존성을 주입하는 것이 가장 좋지만 때로는 필드를 통해 주입해야 하는 경우도 있다.
- 뒷받침하는 필드(backing field)가 존재하는 프로퍼티는 인스턴스화가 될 때 초기화되어야 한다.
- 의존성이 주입될 필드를 널로 초기화할 수 있지만 널이 될 수 있는 타입은 많은 불편을 초래한다.
- 코틀린에서는 lateinit 변경자를 붙이면 프로퍼티를 나중에 초기화할 수 있다. 나중에 초기화하는 프로퍼티는 항상 var여야 한다.

## 잭슨 코틀린 모듈

- 잭슨은 기본적으로 역직렬화 과정을 위해 매개변수가 없는 생성자가 필요하다.
- 코틀린에서 매개변수가 없는 생성자를 만들려면 생성자의 모든 매개변수에 기본 인자를 넣어야 한다.
- 잭슨 코틀린 모듈은 매개변수가 없는 생성자가 없더라도 직렬화와 역직렬화를 지원한다.

---

## 코틀린 애너테이션

---

## 아이템 5. 변경 가능성을 제한하라

- 코틀린의 클래스와 멤버가 final인 것처럼 일단 val로 선언하고 필요할 때 val로 변경한다.
- 스프링 부트 2.2부터 스프링 프로퍼티 클래스에서 생성자 바인딩을 사용할 수 있다.
- 생성자 바인딩을 사용하려면 @EnableConfigurationProperties 또는 @ConfigurationPropertiesScan을 사용하면 된다.
- 클래스에 개념적으로 동일하지만 하나는 공개된 API의 일부이고 다른 하나는 구현 세부 사항인 두 개의 프로퍼티가 있는 경우 private 프로퍼티 이름의 접두사로 밑줄을 사용한다. 이를 뒷받침하는 프로퍼티(backing property)라고 한다.
- JVM에서는 기본 getter 및 setter가 있는 private 프로퍼티에 대해 함수 호출 오버헤드를 방지하도록 최적화되어 있다.

---

# Persistence

## No-arg 컴파일러 플러그인

- JPA에서 엔티티 클래스를 생성하려면 매개변수가 없는 생성자가 필요하다.
- no-arg 컴파일러 플러그인은 지정한 애너테이션이 있는 클래스에 매개변수가 없는 생성자를 추가한다.
- 자바 또는 코틀린에서 직접 호출할 수 없지만 리플렉션을 사용하여 호출할 수 있다.
- kotlin-spring 컴파일러 플러그인과 마찬가지로 JPA를 사용하는 경우 no-arg 컴파일러 플러그인을 래핑한 kotlin-jpa 컴파일러 플러그인을 사용할 수 있다.

**All-open 컴파일러 플러그인, 잭슨 코틀린 모듈, No-arg 컴파일러 플러그인 은 스프링 이니셜라이저로 코틀린 프로젝트를 생성하면 자동으로 추가가 된다.**

---

## 아이템 6. 엔티티에 데이터 클래스 사용을 피하라

- 롬복의 @Data와 같은 맥락이다. 양방향 연관 관계의 경우 toString(), hashCode()를 호출될 때 무한 순환 참조가 발생한다.

---

## 아이템 7. 사용자 지정 getter를 사용하라

- JPA에 의해 인스턴스화 될 때 초기화 블록이 호출되지 않기 때문에 영속화하지 않는 필드는 초기화된 프로퍼티가 아닌 사용자 지정 getter를 사용해야 한다.
- 사용자 지정 getter를 정의하면 프로퍼티에 접근할 때마다 호출된다.
- 뒷받침하는 필드가 존재하지 않기 때문에 AccessType.FIELD이더라도 @Transient을 사용하지 않아도 된다.

---

## 아이템 8. 널이 될 수 있는 타입은 빠르게 제거하라

- 널이 될 수 있는 타입을 사용하면 널 검사를 넣거나 !! 연산자를 써야 한다.
- 아이디를 0 또는 빈 문자열로 초기화하면 널이 될 수 있는 타입을 제거할 수 있다.
- 확장 함수를 사용해 반복되는 널 검사를 제거할 수 있다.

---

코틀린 + 스프링 프로젝트 : [https://github.com/woowacourse/service-apply](https://github.com/woowacourse/service-apply)